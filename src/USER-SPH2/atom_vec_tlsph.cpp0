/* ----------------------------------------------------------------------
 LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
 http://lammps.sandia.gov, Sandia National Laboratories
 Steve Plimpton, sjplimp@sandia.gov

 Copyright (2003) Sandia Corporation.  Under the terms of Contract
 DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
 certain rights in this software.  This software is distributed under
 the GNU General Public License.

 See the README file in the top-level LAMMPS directory.
 ------------------------------------------------------------------------- */

/* ----------------------------------------------------------------------
 Contributing author: Mike Parks (SNL)
 ------------------------------------------------------------------------- */

#include "lmptype.h"
#include "float.h"
#include "stdlib.h"
#include "atom_vec_tlsph.h"
#include "atom.h"
#include "comm.h"
#include "domain.h"
#include "modify.h"
#include "fix.h"
#include "memory.h"
#include "error.h"

using namespace LAMMPS_NS;

#define DELTA 10000
#define NMAT_FULL 9
#define NMAT_SYMM 6

/* ---------------------------------------------------------------------- */

AtomVecTLSPH::AtomVecTLSPH(LAMMPS *lmp, int narg, char **arg) :
        AtomVec(lmp, narg, arg) {
    molecular = 0;

    comm_x_only = 0;
    comm_f_only = 0;
    size_forward = 8 + NMAT_SYMM; //x + vest + e + rho + NMAT_SYMM (stress)
    size_reverse = 5 + NMAT_SYMM; // f + de + drho + NMAT_SYMM stress_rate
    size_border = 21 + NMAT_FULL + NMAT_SYMM; // (F old, P strain, stress);
    size_velocity = 3;
    size_data_atom = 13;
    size_data_vel = 4;
    xcol_data = 8;

    atom->peri_flag = 1;
    atom->vfrac_flag = atom->rmass_flag = 1;
    atom->radius_flag = 1;
    atom->contactRadius_flag = 1;
    atom->perinorm_flag = 1;
    atom->molecule_flag = 1;
    atom->tlsph_fold_flag = 1;
    atom->e_flag = 1;
    atom->vest_flag = 1;
    atom->tlsph_stress_flag = 1;
    atom->tlsph_stress_rate_flag = 1;
    atom->eff_plastic_strain_flag = 1;
    atom->rho_flag = 1;

}

/* ----------------------------------------------------------------------
 grow atom arrays
 n = 0 grows arrays by DELTA
 n > 0 allocates arrays to size n
 ------------------------------------------------------------------------- */

void AtomVecTLSPH::grow(int n) {
    if (n == 0)
        nmax += DELTA;
    else
        nmax = n;
    atom->nmax = nmax;
    if (nmax < 0 || nmax > MAXSMALLINT)
        error->one(FLERR, "Per-processor system is too big");

    tag = memory->grow(atom->tag, nmax, "atom:tag");
    type = memory->grow(atom->type, nmax, "atom:type");
    mask = memory->grow(atom->mask, nmax, "atom:mask");
    image = memory->grow(atom->image, nmax, "atom:image");
    x = memory->grow(atom->x, nmax, 3, "atom:x");
    v = memory->grow(atom->v, nmax, 3, "atom:v");
    f = memory->grow(atom->f, nmax * comm->nthreads, 3, "atom:f");

    vfrac = memory->grow(atom->vfrac, nmax, "atom:vfrac");
    rmass = memory->grow(atom->rmass, nmax, "atom:rmass");
    x0 = memory->grow(atom->x0, nmax, 3, "atom:x0");
    radius = memory->grow(atom->radius, nmax, "atom:radius");
    perinorm = memory->grow(atom->perinorm, nmax, "atom:perinorm");
    radiusSR = memory->grow(atom->contactRadius, nmax, "atom:radiusSR");
    molecule = memory->grow(atom->molecule, nmax, "atom:molecule");
    tlsph_fold = memory->grow(atom->tlsph_fold, nmax, NMAT_FULL, "atom:defgrad_old");
    e = memory->grow(atom->e, nmax, "atom:e");
    de = memory->grow(atom->de, nmax * comm->nthreads, "atom:de");
    vest = memory->grow(atom->vest, nmax, 3, "atom:vest");
    tlsph_stress = memory->grow(atom->tlsph_stress, nmax, NMAT_SYMM, "atom:tlsph_stress");
    tlsph_stress_rate = memory->grow(atom->tlsph_stress_rate, nmax, NMAT_SYMM, "atom:tlsph_stress_rate");
    eff_plastic_strain = memory->grow(atom->eff_plastic_strain, nmax, "atom:eff_plastic_strain");
    rho = memory->grow(atom->rho, nmax, "atom:rho");
    drho = memory->grow(atom->drho, nmax * comm->nthreads, "atom:drho");

    if (atom->nextra_grow)
        for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
            modify->fix[atom->extra_grow[iextra]]->grow_arrays(nmax);
}

/* ----------------------------------------------------------------------
 reset local array ptrs
 ------------------------------------------------------------------------- */

void AtomVecTLSPH::grow_reset() {
    tag = atom->tag;
    type = atom->type;
    mask = atom->mask;
    image = atom->image;
    x = atom->x;
    v = atom->v;
    f = atom->f;
    vfrac = atom->vfrac;
    rmass = atom->rmass;
    x0 = atom->x0;
    radius = atom->radius;
    perinorm = atom->perinorm;
    radiusSR = atom->contactRadius;
    molecule = atom->molecule;
    tlsph_fold = atom->tlsph_fold;
    e = atom->e;
    de = atom->de;
    tlsph_stress = atom->tlsph_stress;
    tlsph_stress_rate = atom->tlsph_stress_rate;
    eff_plastic_strain = atom->eff_plastic_strain;
    rho = atom->rho;
    drho = atom->drho;
}

/* ----------------------------------------------------------------------
 copy atom I info to atom J
 ------------------------------------------------------------------------- */

void AtomVecTLSPH::copy(int i, int j, int delflag) {
    tag[j] = tag[i];
    type[j] = type[i];
    mask[j] = mask[i];
    image[j] = image[i];
    x[j][0] = x[i][0];
    x[j][1] = x[i][1];
    x[j][2] = x[i][2];
    v[j][0] = v[i][0];
    v[j][1] = v[i][1];
    v[j][2] = v[i][2];

    vfrac[j] = vfrac[i];
    rmass[j] = rmass[i];
    x0[j][0] = x0[i][0];
    x0[j][1] = x0[i][1];
    x0[j][2] = x0[i][2];
    radius[j] = radius[i];
    perinorm[j] = perinorm[i];
    radiusSR[j] = radiusSR[i];
    molecule[j] = molecule[i];
    e[j] = e[i];
    rho[j] = rho[i];
    eff_plastic_strain[j] = eff_plastic_strain[i];
    vest[j][0] = vest[i][0];
    vest[j][1] = vest[i][1];
    vest[j][2] = vest[i][2];

    for (int k = 0; k < NMAT_FULL; k++) {
        tlsph_fold[j][k] = tlsph_fold[i][k];
    }

    for (int k = 0; k < NMAT_SYMM; k++) {
        tlsph_stress[j][k] = tlsph_stress[i][k];
    }

    if (atom->nextra_grow)
        for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
            modify->fix[atom->extra_grow[iextra]]->copy_arrays(i, j);
}

/* ---------------------------------------------------------------------- */

int AtomVecTLSPH::pack_comm(int n, int *list, double *buf, int pbc_flag, int *pbc) {
    error->one(FLERR, "atom vec tlsph can only be used with ghost velocities");
}

/* ---------------------------------------------------------------------- */

int AtomVecTLSPH::pack_comm_vel(int n, int *list, double *buf, int pbc_flag, int *pbc)

{
    //printf ("AtomVecTLSPH::pack_comm_vel\n");
    int i, j, m;
    double dx, dy, dz, dvx, dvy, dvz;

    m = 0;
    if (pbc_flag == 0) {
        for (i = 0; i < n; i++) {
            j = list[i];
            buf[m++] = x[j][0];
            buf[m++] = x[j][1];
            buf[m++] = x[j][2]; // 3
            buf[m++] = v[j][0];
            buf[m++] = v[j][1];
            buf[m++] = v[j][2]; // 6
            buf[m++] = vest[j][0];
            buf[m++] = vest[j][1];
            buf[m++] = vest[j][2]; // 9
            buf[m++] = e[j]; // 10
            buf[m++] = rho[j];

            for (int k = 0; k < NMAT_SYMM; k++) { // 10 + NMAT_SYMM
                buf[m++] = tlsph_stress[j][k];
            }
        }
    } else {
        if (domain->triclinic == 0) {
            dx = pbc[0] * domain->xprd;
            dy = pbc[1] * domain->yprd;
            dz = pbc[2] * domain->zprd;
        } else {
            dx = pbc[0] * domain->xprd + pbc[5] * domain->xy + pbc[4] * domain->xz;
            dy = pbc[1] * domain->yprd + pbc[3] * domain->yz;
            dz = pbc[2] * domain->zprd;
        }
        if (!deform_vremap) {
            for (i = 0; i < n; i++) {
                j = list[i];
                //printf("pbcflag = %d, pbc[0]=%d, pbc[1]=%d, pbc[2]=%d, dx=%f\n", pbc_flag, pbc[0], pbc[1], pbc[2], dx);
                buf[m++] = x[j][0] + dx;
                buf[m++] = x[j][1] + dy;
                buf[m++] = x[j][2] + dz;
                buf[m++] = v[j][0];
                buf[m++] = v[j][1];
                buf[m++] = v[j][2];
                buf[m++] = vest[j][0];
                buf[m++] = vest[j][1];
                buf[m++] = vest[j][2];
                buf[m++] = e[j];
                buf[m++] = rho[j];

                for (int k = 0; k < NMAT_SYMM; k++) {
                    buf[m++] = tlsph_stress[j][k];
                }
            }
        } else {
            dvx = pbc[0] * h_rate[0] + pbc[5] * h_rate[5] + pbc[4] * h_rate[4];
            dvy = pbc[1] * h_rate[1] + pbc[3] * h_rate[3];
            dvz = pbc[2] * h_rate[2];
            for (i = 0; i < n; i++) {
                j = list[i];
                buf[m++] = x[j][0] + dx;
                buf[m++] = x[j][1] + dy;
                buf[m++] = x[j][2] + dz;
                if (mask[i] & deform_groupbit) {
                    buf[m++] = v[j][0] + dvx;
                    buf[m++] = v[j][1] + dvy;
                    buf[m++] = v[j][2] + dvz;
                    buf[m++] = vest[j][0] + dvx;
                    buf[m++] = vest[j][1] + dvy;
                    buf[m++] = vest[j][2] + dvz;
                } else {
                    buf[m++] = v[j][0];
                    buf[m++] = v[j][1];
                    buf[m++] = v[j][2];
                    buf[m++] = vest[j][0];
                    buf[m++] = vest[j][1];
                    buf[m++] = vest[j][2];
                }

                buf[m++] = e[j];
                buf[m++] = rho[j];

                for (int k = 0; k < NMAT_SYMM; k++) {
                    buf[m++] = tlsph_stress[j][k];
                }
            }
        }
    }
    return m;
}

/* ---------------------------------------------------------------------- */

void AtomVecTLSPH::unpack_comm(int n, int first, double *buf) {
    error->one(FLERR, "atom vec tlsph can only be used with ghost velocities");
}

/* ---------------------------------------------------------------------- */

void AtomVecTLSPH::unpack_comm_vel(int n, int first, double *buf) {
    int i, m, last;

    m = 0;
    last = first + n;
    for (i = first; i < last; i++) {
        x[i][0] = buf[m++];
        x[i][1] = buf[m++];
        x[i][2] = buf[m++];
        v[i][0] = buf[m++];
        v[i][1] = buf[m++];
        v[i][2] = buf[m++];
        vest[i][0] = buf[m++];
        vest[i][1] = buf[m++];
        vest[i][2] = buf[m++];
        e[i] = buf[m++];
        rho[i] = buf[m++];

        for (int k = 0; k < NMAT_SYMM; k++) {
            tlsph_stress[i][k] = buf[m++];
        }
    }
}

/* ---------------------------------------------------------------------- */

int AtomVecTLSPH::pack_reverse(int n, int first, double *buf) {
    int i, m, last;

    m = 0;
    last = first + n;
    printf("packing reverse\n");
    for (i = first; i < last; i++) {
        buf[m++] = f[i][0];
        buf[m++] = f[i][1];
        buf[m++] = f[i][2];
        buf[m++] = de[i];
        buf[m++] = drho[i];

        for (int k = 0; k < NMAT_SYMM; k++) {
            buf[m++] = tlsph_stress_rate[i][k];
        }
    }
    return m;
}

/* ---------------------------------------------------------------------- */

void AtomVecTLSPH::unpack_reverse(int n, int *list, double *buf) {
    int i, j, m;

    m = 0;
    for (i = 0; i < n; i++) {
        j = list[i];
        f[j][0] += buf[m++];
        f[j][1] += buf[m++];
        f[j][2] += buf[m++];
        de[j] += buf[m++];
        drho[j] += buf[m++];

        for (int k = 0; k < NMAT_SYMM; k++) {
            tlsph_stress_rate[j][k] = buf[m++];
        }
    }
}

/* ---------------------------------------------------------------------- */

int AtomVecTLSPH::pack_border(int n, int *list, double *buf, int pbc_flag, int *pbc) {
    error->one(FLERR, "atom vec tlsph can only be used with ghost velocities");
    return 0;
}

/* ---------------------------------------------------------------------- */

int AtomVecTLSPH::pack_border_vel(int n, int *list, double *buf, int pbc_flag, int *pbc) {

    //printf(" ********** packing BORDER_VEL **********\n");

    int i, j, m;
    double dx, dy, dz, dvx, dvy, dvz;

    m = 0;
    if (pbc_flag == 0) {
        //printf(" ********** packing BORDER_VEL w/o. PBC**********\n");
        for (i = 0; i < n; i++) {
            j = list[i];
            buf[m++] = x[j][0];
            buf[m++] = x[j][1];
            buf[m++] = x[j][2]; // 3
            buf[m++] = tag[j];
            buf[m++] = type[j];
            buf[m++] = mask[j];
            buf[m++] = vfrac[j]; // 3
            buf[m++] = x0[j][0];
            buf[m++] = x0[j][1];
            buf[m++] = x0[j][2]; //10
            buf[m++] = radius[j];
            buf[m++] = rmass[j];
            buf[m++] = perinorm[j];
            buf[m++] = radiusSR[j];
            buf[m++] = molecule[j];
            buf[m++] = e[j]; //16
            buf[m++] = rho[j]; //16
            buf[m++] = eff_plastic_strain[j]; //17

            for (int k = 0; k < NMAT_FULL; k++) {
                buf[m++] = tlsph_fold[j][k];
            }

            for (int k = 0; k < NMAT_SYMM; k++) {
                buf[m++] = tlsph_stress[j][k];
            }

            buf[m++] = v[j][0]; //
            buf[m++] = v[j][1]; // don't dount
            buf[m++] = v[j][2]; //
            buf[m++] = vest[j][0]; //
            buf[m++] = vest[j][1]; //
            buf[m++] = vest[j][2]; // 20 + NMAT_FULL + NMAT_SYMM
        }
    } else {
        if (domain->triclinic == 0) {
            dx = pbc[0] * domain->xprd;
            dy = pbc[1] * domain->yprd;
            dz = pbc[2] * domain->zprd;
        } else {
            dx = pbc[0];
            dy = pbc[1];
            dz = pbc[2];
        }
        if (!deform_vremap) {
            //printf(" ********** packing BORDER_VEL w. PBC**********\n");
            for (i = 0; i < n; i++) {
                j = list[i];
                buf[m++] = x[j][0] + dx;
                buf[m++] = x[j][1] + dy;
                buf[m++] = x[j][2] + dz;
                buf[m++] = tag[j];
                buf[m++] = type[j];
                buf[m++] = mask[j];
                buf[m++] = vfrac[j];
                buf[m++] = x0[j][0] + dx;
                buf[m++] = x0[j][1] + dy;
                buf[m++] = x0[j][2] + dz;
                buf[m++] = radius[j];
                buf[m++] = rmass[j];
                buf[m++] = perinorm[j];
                buf[m++] = radiusSR[j];
                buf[m++] = molecule[j];
                buf[m++] = e[j];
                buf[m++] = rho[j]; //16
                buf[m++] = eff_plastic_strain[j];

                for (int k = 0; k < NMAT_FULL; k++) {
                    buf[m++] = tlsph_fold[j][k];
                }

                for (int k = 0; k < NMAT_SYMM; k++) {
                    buf[m++] = tlsph_stress[j][k];
                }

                buf[m++] = v[j][0];
                buf[m++] = v[j][1];
                buf[m++] = v[j][2];
                buf[m++] = vest[j][0];
                buf[m++] = vest[j][1];
                buf[m++] = vest[j][2];
            }
        } else {
            printf(" ********** packing BORDER_VEL w. PBC & hrate**********\n");
            dvx = pbc[0] * h_rate[0] + pbc[5] * h_rate[5] + pbc[4] * h_rate[4];
            dvy = pbc[1] * h_rate[1] + pbc[3] * h_rate[3];
            dvz = pbc[2] * h_rate[2];
            for (i = 0; i < n; i++) {
                j = list[i];
                buf[m++] = x[j][0] + dx;
                buf[m++] = x[j][1] + dy;
                buf[m++] = x[j][2] + dz;
                buf[m++] = tag[j];
                buf[m++] = type[j];
                buf[m++] = mask[j];
                buf[m++] = vfrac[j];
                buf[m++] = x0[j][0];
                buf[m++] = x0[j][1];
                buf[m++] = x0[j][2];
                buf[m++] = radius[j];
                buf[m++] = rmass[j];
                buf[m++] = perinorm[j];
                buf[m++] = radiusSR[j];
                buf[m++] = molecule[j];
                buf[m++] = e[j];
                buf[m++] = rho[j]; //16
                buf[m++] = eff_plastic_strain[j];

                for (int k = 0; k < NMAT_FULL; k++) {
                    buf[m++] = tlsph_fold[j][k];
                }

                for (int k = 0; k < NMAT_SYMM; k++) {
                    buf[m++] = tlsph_stress[j][k];
                }

                if (mask[i] & deform_groupbit) {
                    buf[m++] = v[j][0] + dvx;
                    buf[m++] = v[j][1] + dvy;
                    buf[m++] = v[j][2] + dvz;
                    buf[m++] = vest[j][0] + dvx;
                    buf[m++] = vest[j][1] + dvy;
                    buf[m++] = vest[j][2] + dvz;
                } else {
                    buf[m++] = v[j][0];
                    buf[m++] = v[j][1];
                    buf[m++] = v[j][2];
                    buf[m++] = vest[j][0];
                    buf[m++] = vest[j][1];
                    buf[m++] = vest[j][2];
                }
            }
        }
    }
    return m;
}

/* ---------------------------------------------------------------------- */

int AtomVecTLSPH::pack_border_hybrid(int n, int *list, double *buf) {
    int i, j, m;

    m = 0;
    for (i = 0; i < n; i++) {
        j = list[i];
        buf[m++] = vfrac[j];
        buf[m++] = x0[j][0];
        buf[m++] = x0[j][1];
        buf[m++] = x0[j][2];
        buf[m++] = radius[j];
        buf[m++] = rmass[j];
        buf[m++] = perinorm[j];
        buf[m++] = radiusSR[j];
        buf[m++] = molecule[j];
        buf[m++] = e[j];
        buf[m++] = rho[j];
        buf[m++] = eff_plastic_strain[j];
        buf[m++] = vest[j][0];
        buf[m++] = vest[j][1];
        buf[m++] = vest[j][2];

        for (int k = 0; k < NMAT_FULL; k++) {
            buf[m++] = tlsph_fold[j][k];
        }

        for (int k = 0; k < NMAT_SYMM; k++) {
            buf[m++] = tlsph_stress[j][k];
        }

    }
    return m;
}

/* ---------------------------------------------------------------------- */

void AtomVecTLSPH::unpack_border(int n, int first, double *buf) {
    error->one(FLERR, "atom vec tlsph can only be used with ghost velocities");
}

/* ---------------------------------------------------------------------- */

void AtomVecTLSPH::unpack_border_vel(int n, int first, double *buf) {
    int i, m, last;

    m = 0;
    last = first + n;
    for (i = first; i < last; i++) {
        if (i == nmax)
            grow(0);
        x[i][0] = buf[m++];
        x[i][1] = buf[m++];
        x[i][2] = buf[m++];
        tag[i] = static_cast<int>(buf[m++]);
        type[i] = static_cast<int>(buf[m++]);
        mask[i] = static_cast<int>(buf[m++]);
        vfrac[i] = buf[m++];
        x0[i][0] = buf[m++];
        x0[i][1] = buf[m++];
        x0[i][2] = buf[m++];
        radius[i] = buf[m++];
        rmass[i] = buf[m++];
        perinorm[i] = buf[m++];
        radiusSR[i] = buf[m++];
        molecule[i] = static_cast<int>(buf[m++]);
        e[i] = buf[m++];
        rho[i] = buf[m++];
        eff_plastic_strain[i] = buf[m++];

        for (int k = 0; k < NMAT_FULL; k++) {
            tlsph_fold[i][k] = buf[m++];
        }

        for (int k = 0; k < NMAT_SYMM; k++) {
            tlsph_stress[i][k] = buf[m++];
        }

        v[i][0] = buf[m++];
        v[i][1] = buf[m++];
        v[i][2] = buf[m++];
        vest[i][0] = buf[m++];
        vest[i][1] = buf[m++];
        vest[i][2] = buf[m++];
    }
}

/* ---------------------------------------------------------------------- */

int AtomVecTLSPH::unpack_border_hybrid(int n, int first, double *buf) {
    int i, m, last;

    m = 0;
    last = first + n;
    for (i = first; i < last; i++) {
        vfrac[i] = buf[m++];
        x0[i][0] = buf[m++];
        x0[i][1] = buf[m++];
        x0[i][2] = buf[m++];
        radius[i] = buf[m++];
        rmass[i] = buf[m++];
        perinorm[i] = buf[m++];
        radiusSR[i] = buf[m++];
        molecule[i] = static_cast<int>(buf[m++]);
        e[i] = buf[m++];
        rho[i] = buf[m++];
        eff_plastic_strain[i] = buf[m++];
        vest[i][0] = buf[m++];
        vest[i][1] = buf[m++];
        vest[i][2] = buf[m++];

        for (int k = 0; k < NMAT_FULL; k++) {
            tlsph_fold[i][k] = buf[m++];
        }

        for (int k = 0; k < NMAT_SYMM; k++) {
            tlsph_stress[i][k] = buf[m++];
        }

    }
    return m;
}

/* ----------------------------------------------------------------------
 pack data for atom I for sending to another proc
 xyz must be 1st 3 values, so comm::exchange() can test on them
 ------------------------------------------------------------------------- */

int AtomVecTLSPH::pack_exchange(int i, double *buf) {

    //printf(" ********** packing EXCHANGE **********");

    int m = 1;
    buf[m++] = x[i][0];
    buf[m++] = x[i][1];
    buf[m++] = x[i][2];
    buf[m++] = v[i][0];
    buf[m++] = v[i][1];
    buf[m++] = v[i][2];
    buf[m++] = vest[i][0];
    buf[m++] = vest[i][1];
    buf[m++] = vest[i][2];
    buf[m++] = tag[i];
    buf[m++] = type[i];
    buf[m++] = mask[i];
    buf[m++] = image[i];

    buf[m++] = vfrac[i];
    buf[m++] = rmass[i];
    buf[m++] = x0[i][0];
    buf[m++] = x0[i][1];
    buf[m++] = x0[i][2];
    buf[m++] = radius[i];
    buf[m++] = perinorm[i];
    buf[m++] = radiusSR[i];
    buf[m++] = molecule[i];
    buf[m++] = e[i];
    buf[m++] = rho[i];
    buf[m++] = eff_plastic_strain[i];

    for (int k = 0; k < NMAT_FULL; k++) {
        buf[m++] = tlsph_fold[i][k];
    }

    for (int k = 0; k < NMAT_SYMM; k++) {
        buf[m++] = tlsph_stress[i][k];
    }

    if (atom->nextra_grow)
        for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
            m += modify->fix[atom->extra_grow[iextra]]->pack_exchange(i, &buf[m]);

    buf[0] = m;
    return m;
}

/* ---------------------------------------------------------------------- */

int AtomVecTLSPH::unpack_exchange(double *buf) {
    int nlocal = atom->nlocal;
    if (nlocal == nmax)
        grow(0);

    int m = 1;
    x[nlocal][0] = buf[m++];
    x[nlocal][1] = buf[m++];
    x[nlocal][2] = buf[m++];
    v[nlocal][0] = buf[m++];
    v[nlocal][1] = buf[m++];
    v[nlocal][2] = buf[m++];
    vest[nlocal][0] = buf[m++];
    vest[nlocal][1] = buf[m++];
    vest[nlocal][2] = buf[m++];
    tag[nlocal] = static_cast<int>(buf[m++]);
    type[nlocal] = static_cast<int>(buf[m++]);
    mask[nlocal] = static_cast<int>(buf[m++]);
    image[nlocal] = static_cast<int>(buf[m++]);

    vfrac[nlocal] = buf[m++];
    rmass[nlocal] = buf[m++];
    x0[nlocal][0] = buf[m++];
    x0[nlocal][1] = buf[m++];
    x0[nlocal][2] = buf[m++];
    radius[nlocal] = buf[m++];
    perinorm[nlocal] = buf[m++];
    radiusSR[nlocal] = buf[m++];
    molecule[nlocal] = static_cast<int>(buf[m++]);
    e[nlocal] = buf[m++];
    rho[nlocal] = buf[m++];
    eff_plastic_strain[nlocal] = buf[m++];

    for (int k = 0; k < NMAT_FULL; k++) {
        tlsph_fold[nlocal][k] = buf[m++];
    }

    for (int k = 0; k < NMAT_SYMM; k++) {
        tlsph_stress[nlocal][k] = buf[m++];
    }

    if (atom->nextra_grow)
        for (int iextra = 0; iextra < atom->nextra_grow; iextra++)
            m += modify->fix[atom->extra_grow[iextra]]->unpack_exchange(nlocal, &buf[m]);

    atom->nlocal++;
    return m;
}

/* ----------------------------------------------------------------------
 size of restart data for all atoms owned by this proc
 include extra data stored by fixes
 ------------------------------------------------------------------------- */

int AtomVecTLSPH::size_restart() {
    int i;

    int nlocal = atom->nlocal;
    int n = 30 * nlocal; // this is the number of items packed in pack_restart + 1

    if (atom->nextra_restart)
        for (int iextra = 0; iextra < atom->nextra_restart; iextra++)
            for (i = 0; i < nlocal; i++)
                n += modify->fix[atom->extra_restart[iextra]]->size_restart(i);

    return n;
}

/* ----------------------------------------------------------------------
 pack atom I's data for restart file including extra quantities
 xyz must be 1st 3 values, so that read_restart can test on them
 molecular types may be negative, but write as positive
 ------------------------------------------------------------------------- */

int AtomVecTLSPH::pack_restart(int i, double *buf) {
    int m = 1;
    buf[m++] = x[i][0];
    buf[m++] = x[i][1];
    buf[m++] = x[i][2];
    buf[m++] = tag[i];
    buf[m++] = type[i];
    buf[m++] = mask[i];
    buf[m++] = image[i];
    buf[m++] = v[i][0];
    buf[m++] = v[i][1];
    buf[m++] = v[i][2]; //10
    buf[m++] = vest[i][0];
    buf[m++] = vest[i][1];
    buf[m++] = vest[i][2]; //13
    buf[m++] = vfrac[i];
    buf[m++] = rmass[i];
    buf[m++] = x0[i][0];
    buf[m++] = x0[i][1];
    buf[m++] = x0[i][2];
    buf[m++] = radius[i];
    buf[m++] = perinorm[i]; //20
    buf[m++] = radiusSR[i];
    buf[m++] = molecule[i];
    buf[m++] = e[i]; //23
    buf[m++] = rho[i]; //23
    buf[m++] = eff_plastic_strain[i]; //34

    for (int k = 0; k < NMAT_FULL; k++) {
        buf[m++] = tlsph_fold[i][k];
    } // 31

    for (int k = 0; k < NMAT_SYMM; k++) {
        buf[m++] = tlsph_stress[i][k];
    } // 35

    if (atom->nextra_restart)
        for (int iextra = 0; iextra < atom->nextra_restart; iextra++)
            m += modify->fix[atom->extra_restart[iextra]]->pack_restart(i, &buf[m]);

    buf[0] = m;
    return m;
}

/* ----------------------------------------------------------------------
 unpack data for one atom from restart file including extra quantities
 ------------------------------------------------------------------------- */

int AtomVecTLSPH::unpack_restart(double *buf) {
    int nlocal = atom->nlocal;
    if (nlocal == nmax) {
        grow(0);
        if (atom->nextra_store)
            memory->grow(atom->extra, nmax, atom->nextra_store, "atom:extra");
    }

    int m = 1;
    x[nlocal][0] = buf[m++];
    x[nlocal][1] = buf[m++];
    x[nlocal][2] = buf[m++];
    tag[nlocal] = static_cast<int>(buf[m++]);
    type[nlocal] = static_cast<int>(buf[m++]);
    mask[nlocal] = static_cast<int>(buf[m++]);
    image[nlocal] = static_cast<int>(buf[m++]);
    v[nlocal][0] = buf[m++];
    v[nlocal][1] = buf[m++];
    v[nlocal][2] = buf[m++];
    vest[nlocal][0] = buf[m++];
    vest[nlocal][1] = buf[m++];
    vest[nlocal][2] = buf[m++];

    vfrac[nlocal] = buf[m++];
    rmass[nlocal] = buf[m++];
    x0[nlocal][0] = buf[m++];
    x0[nlocal][1] = buf[m++];
    x0[nlocal][2] = buf[m++];
    radius[nlocal] = buf[m++];
    perinorm[nlocal] = buf[m++];
    radiusSR[nlocal] = buf[m++];
    molecule[nlocal] = static_cast<int>(buf[m++]);
    e[nlocal] = buf[m++];
    rho[nlocal] = buf[m++];
    eff_plastic_strain[nlocal] = buf[m++];

    for (int k = 0; k < NMAT_FULL; k++) {
        tlsph_fold[nlocal][k] = buf[m++];
    }

    for (int k = 0; k < NMAT_SYMM; k++) {
        tlsph_stress[nlocal][k] = buf[m++];
    }

    double **extra = atom->extra;
    if (atom->nextra_store) {
        int size = static_cast<int>(buf[0]) - m;
        for (int i = 0; i < size; i++)
            extra[nlocal][i] = buf[m++];
    }

    atom->nlocal++;
    return m;
}

/* ----------------------------------------------------------------------
 create one atom of itype at coord
 set other values to defaults
 ------------------------------------------------------------------------- */

void AtomVecTLSPH::create_atom(int itype, double *coord) {
    int nlocal = atom->nlocal;
    if (nlocal == nmax)
        grow(0);

    //printf("adding one atom\n");

    tag[nlocal] = 0;
    type[nlocal] = itype;
    x[nlocal][0] = coord[0];
    x[nlocal][1] = coord[1];
    x[nlocal][2] = coord[2];
    mask[nlocal] = 1;
    image[nlocal] = (512 << 20) | (512 << 10) | 512;
    v[nlocal][0] = 0.0;
    v[nlocal][1] = 0.0;
    v[nlocal][2] = 0.0;
    vest[nlocal][0] = 0.0;
    vest[nlocal][1] = 0.0;
    vest[nlocal][2] = 0.0;

    vfrac[nlocal] = 1.0;
    rmass[nlocal] = 1.0;
    x0[nlocal][0] = coord[0];
    x0[nlocal][1] = coord[1];
    x0[nlocal][2] = coord[2];
    radius[nlocal] = 1.0;
    perinorm[nlocal] = 1.0;
    radiusSR[nlocal] = 0.5;
    molecule[nlocal] = 1;
    e[nlocal] = 0.0;
    rho[nlocal] = 0.0;
    eff_plastic_strain[nlocal] = 0.0;

    for (int k = 0; k < NMAT_FULL; k++) {
        tlsph_fold[nlocal][k] = 0.0;
    }

    for (int k = 0; k < NMAT_SYMM; k++) {
        tlsph_stress[nlocal][k] = 0.0;
    }

    tlsph_fold[nlocal][0] = 1.0; // xx
    tlsph_fold[nlocal][4] = 1.0; // yy
    tlsph_fold[nlocal][8] = 1.0; // zz

    atom->nlocal++;
}

/* ----------------------------------------------------------------------
 unpack one line from Atoms section of data file
 initialize other atom quantities
 ------------------------------------------------------------------------- */

void AtomVecTLSPH::data_atom(double *coord, int imagetmp, char **values) {
    int nlocal = atom->nlocal;
    if (nlocal == nmax)
        grow(0);

    tag[nlocal] = atoi(values[0]);
    if (tag[nlocal] <= 0)
        error->one(FLERR, "Invalid atom ID in Atoms section of data file");

    type[nlocal] = atoi(values[1]);
    if (type[nlocal] <= 0 || type[nlocal] > atom->ntypes)
        error->one(FLERR, "Invalid atom type in Atoms section of data file");

    molecule[nlocal] = atoi(values[2]);
    if (molecule[nlocal] <= 0)
        error->one(FLERR, "Invalid molecule in Atoms section of data file");

    vfrac[nlocal] = atof(values[3]);
    rmass[nlocal] = atof(values[4]);
    if (rmass[nlocal] == 0.0)
        error->one(FLERR, "Invalid mass value particle");

    radius[nlocal] = atof(values[5]);
    radiusSR[nlocal] = atof(values[6]);

    x[nlocal][0] = coord[0];
    x[nlocal][1] = coord[1];
    x[nlocal][2] = coord[2];

    x0[nlocal][0] = coord[0];
    x0[nlocal][1] = coord[1];
    x0[nlocal][2] = coord[2];

    image[nlocal] = imagetmp;

    mask[nlocal] = 1;
    v[nlocal][0] = 0.0;
    v[nlocal][1] = 0.0;
    v[nlocal][2] = 0.0;
    vest[nlocal][0] = 0.0;
    vest[nlocal][1] = 0.0;
    vest[nlocal][2] = 0.0;

    e[nlocal] = 0.0;
    rho[nlocal] = 0.0;
    eff_plastic_strain[nlocal] = 0.0;

    for (int k = 0; k < NMAT_FULL; k++) {
        tlsph_fold[nlocal][k] = 0.0;
    }

    for (int k = 0; k < NMAT_SYMM; k++) {
        tlsph_stress[nlocal][k] = 0.0;
    }

    tlsph_fold[nlocal][0] = 1.0; // xx
    tlsph_fold[nlocal][4] = 1.0; // yy
    tlsph_fold[nlocal][8] = 1.0; // zz

    atom->nlocal++;
}

/* ----------------------------------------------------------------------
 unpack hybrid quantities from one line in Atoms section of data file
 initialize other atom quantities for this sub-style
 ------------------------------------------------------------------------- */

int AtomVecTLSPH::data_atom_hybrid(int nlocal, char **values) {

    molecule[nlocal] = atoi(values[0]);
    if (molecule[nlocal] <= 0)
        error->one(FLERR, "Invalid molecule in Atoms section of data file");

    vfrac[nlocal] = atof(values[1]);
    rmass[nlocal] = atof(values[2]);
    if (rmass[nlocal] <= 0.0)
        error->one(FLERR, "Invalid mass value");

    radius[nlocal] = atof(values[3]);
    radiusSR[nlocal] = atof(values[4]);

    return 5;
}

/* ----------------------------------------------------------------------
 return # of bytes of allocated memory
 ------------------------------------------------------------------------- */

bigint AtomVecTLSPH::memory_usage() {
    bigint bytes = 0;

    if (atom->memcheck("tag"))
        bytes += memory->usage(tag, nmax);
    if (atom->memcheck("type"))
        bytes += memory->usage(type, nmax);
    if (atom->memcheck("mask"))
        bytes += memory->usage(mask, nmax);
    if (atom->memcheck("image"))
        bytes += memory->usage(image, nmax);
    if (atom->memcheck("x"))
        bytes += memory->usage(x, nmax, 3);
    if (atom->memcheck("v"))
        bytes += memory->usage(v, nmax, 3);
    if (atom->memcheck("vest"))
        bytes += memory->usage(vest, nmax, 3);
    if (atom->memcheck("f"))
        bytes += memory->usage(f, nmax * comm->nthreads, 3);

    if (atom->memcheck("vfrac"))
        bytes += memory->usage(vfrac, nmax);
    if (atom->memcheck("rmass"))
        bytes += memory->usage(rmass, nmax);
    if (atom->memcheck("x0"))
        bytes += memory->usage(x0, nmax, 3);
    if (atom->memcheck("radius"))
        bytes += memory->usage(radius, nmax);
    if (atom->memcheck("perinorm"))
        bytes += memory->usage(perinorm, nmax);
    if (atom->memcheck("radiusSR"))
        bytes += memory->usage(radiusSR, nmax);
    if (atom->memcheck("molecule"))
        bytes += memory->usage(molecule, nmax);
    if (atom->memcheck("e"))
        bytes += memory->usage(e, nmax);
    if (atom->memcheck("eff_plastic_strain"))
        bytes += memory->usage(eff_plastic_strain, nmax);

    if (atom->memcheck("tlsph_fold"))
        bytes += memory->usage(tlsph_fold, nmax, NMAT_FULL);

    if (atom->memcheck("tlsph_stress"))
        bytes += memory->usage(tlsph_stress, nmax, NMAT_SYMM);

    if (atom->memcheck("tlsph_stress_rate"))
        bytes += memory->usage(tlsph_stress_rate, nmax, NMAT_SYMM);

    if (atom->memcheck("rho"))
        bytes += memory->usage(rho, nmax);
    if (atom->memcheck("drho"))
        bytes += memory->usage(drho, nmax * comm->nthreads);

    return bytes;
}
